/// <reference types="node" />
import * as path from 'path';
import * as fs from 'fs';
// Load regions.json at runtime from the dist/lib directory
function loadRegions() {
    // Get the directory of the current module
    // In CommonJS (compiled output), __dirname is available at runtime
    // When packed, the file structure may be different, so we check multiple paths
    // __dirname will be available at runtime in CommonJS output from rollup
    // Use __dirname directly since it's available at runtime in CommonJS output
    var moduleDir = __dirname;
    // Try multiple possible paths:
    // 1. lib/regions.json (relative to __dirname - for production/packed package)
    //    Main entry point is dist/index.es.js, so __dirname is dist, file is at dist/lib/regions.json
    // 2. dist/lib/regions.json (relative to process.cwd() - for development/tests)
    var possiblePaths = [
        path.join(moduleDir, 'lib', 'regions.json'),
        path.join(process.cwd(), 'dist', 'lib', 'regions.json'),
    ];
    for (var _i = 0, possiblePaths_1 = possiblePaths; _i < possiblePaths_1.length; _i++) {
        var regionsPath = possiblePaths_1[_i];
        if (fs.existsSync(regionsPath)) {
            try {
                var regionsData = fs.readFileSync(regionsPath, 'utf-8');
                return JSON.parse(regionsData);
            }
            catch (error) {
                throw new Error("Failed to parse regions.json: ".concat(error instanceof Error ? error.message : String(error)));
            }
        }
    }
    // If not found, throw clear error
    throw new Error('regions.json file not found. Please ensure the package is properly installed and postinstall script has run.');
}
// Cache the loaded regions data
var cachedRegions = null;
function getRegions() {
    if (!cachedRegions) {
        cachedRegions = loadRegions();
    }
    return cachedRegions;
}
export function getContentstackEndpoint(region, service, omitHttps) {
    if (region === void 0) { region = 'us'; }
    if (service === void 0) { service = ''; }
    if (omitHttps === void 0) { omitHttps = false; }
    // Validate empty region before any processing
    if (region === '') {
        throw new Error('Empty region provided. Please put valid region.');
    }
    var regionsData = getRegions();
    // Normalize the region input
    var normalizedRegion = region.toLowerCase().trim() || 'us';
    // Check if regions data is malformed
    if (!Array.isArray(regionsData.regions)) {
        throw new Error('Invalid Regions file. Please install the SDK again to fix this issue.');
    }
    // Find the region by ID or alias
    var regionData = findRegionByIDOrAlias(regionsData.regions, normalizedRegion);
    if (!regionData) {
        throw new Error("Invalid region: ".concat(region));
    }
    // Get the endpoint(s)
    if (service) {
        // Return specific service endpoint
        var endpoint = regionData.endpoints[service];
        if (!endpoint) {
            throw new Error("Service \"".concat(service, "\" not found for region \"").concat(regionData.id, "\""));
        }
        return omitHttps ? stripHttps(endpoint) : endpoint;
    }
    else {
        return omitHttps ? stripHttps(regionData.endpoints) : regionData.endpoints;
    }
}
function findRegionByIDOrAlias(regions, regionInput) {
    // First try to find by exact ID match
    var region = regions.find(function (r) { return r.id === regionInput; });
    if (region) {
        return region;
    }
    // Then try to find by alias
    region = regions.find(function (r) {
        return r.alias.some(function (alias) { return alias.toLowerCase() === regionInput.toLowerCase(); });
    });
    return region || null;
}
function stripHttps(endpoint) {
    if (typeof endpoint === 'string') {
        return endpoint.replace(/^https?:\/\//, '');
    }
    else {
        var result = {};
        for (var key in endpoint) {
            result[key] = stripHttps(endpoint[key]);
        }
        return result;
    }
}
//# sourceMappingURL=endpoints.js.map